require_relative '../test_helper'

describe EllipticCurve::Ecdsa do
  it 'verifies the right message' do
    privateKey = EllipticCurve::PrivateKey.new()
    publicKey = privateKey.publicKey()
    message = "This is the right message"
    signature = EllipticCurve::Ecdsa.sign(message, privateKey)
    expect(EllipticCurve::Ecdsa.verify(message, signature, publicKey)).must_equal true
  end
  
  it 'will not verify the wrong message' do
    privateKey = EllipticCurve::PrivateKey.new()
    publicKey = privateKey.publicKey()
    message1 = "This is the right message"
    message2 = "This is the wrong message"
    signature = EllipticCurve::Ecdsa.sign(message1, privateKey)
    expect(EllipticCurve::Ecdsa.verify(message2, signature, publicKey)).must_equal false
  end
  
  it 'can read a private key from a file' do
    # Generated by: openssl ecparam -name secp256k1 -genkey -out privateKey.pem
    privateKeyPem = read_file("test/fixtures/privateKey.pem")
    privateKey = EllipticCurve::PrivateKey.fromPem(privateKeyPem)
    message = read_file("test/fixtures/message.txt")
    signature = EllipticCurve::Ecdsa.sign(message, privateKey)
    publicKey = privateKey.publicKey()
    expect(EllipticCurve::Ecdsa.verify(message, signature, publicKey)).must_equal true
  end

  it 'can verify a signature from a public key' do
    # openssl ec -in privateKey.pem -pubout -out publicKey.pem
    publicKeyPem = read_file("test/fixtures/publicKey.pem")
    # openssl dgst -sha256 -sign privateKey.pem -out signature.binary message.txt
    signatureDer = read_file("test/fixtures/signatureDer.txt", "binary")
    message = read_file("test/fixtures/message.txt")
    publicKey = EllipticCurve::PublicKey.fromPem(publicKeyPem)
    signature = EllipticCurve::Signature.fromDer(signatureDer)
    expect(EllipticCurve::Ecdsa.verify(message, signature, publicKey)).must_equal true
  end
end